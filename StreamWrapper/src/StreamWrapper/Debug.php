<?php
namespace StreamWrapper;

class Debug
{
    private $pointer;
    private $currentSize;
    private $mode;

    private static $readChunks = 0;

    /**
     * Called when opening the stream wrapper, right before streamWrapper::stream_open().
     */
    public function __construct()
    {
        print __METHOD__ . "\n";
        $this->currentSize = 24610;
        return true;
    }

    /**
     * Called when closing the stream wrapper, right before streamWrapper::stream_flush().
     */
    public function __destruct()
    {
        print __METHOD__ . "\n";
        return true;
    }

    /**
     *  This method is called in response to closedir().
     *  Any resources which were locked, or allocated, during opening and use of the directory stream should be released.
     */
    public function dir_closedir()
    {
        print __METHOD__ . "\n";
        return true;
    }

    /**
     * This method is called in response to opendir().
     */
    public function dir_opendir($path, $options)
    {
        print __METHOD__ . "\n";
        return true;
    }

    /**
     * This method is called in response to readdir().
     */
    public function dir_readdir()
    {
        print __METHOD__ . "\n";
        return 'filename.txt';
    }

    /**
     *  This method is called in response to rewinddir().
     *  Should reset the output generated by streamWrapper::dir_readdir().
     *  i.e.: The next call to streamWrapper::dir_readdir() should return
     *  the first entry in the location returned by streamWrapper::dir_opendir().
     */
    public function dir_rewinddir()
    {
        print __METHOD__ . "\n";
        return true;
    }

    /**
     * This method is called in response to mkdir().
     */
    public function mkdir($path, $mode, $options)
    {
        print __METHOD__ . "\n";
    }

    /**
     *  This method is called in response to rename().
     *  Should attempt to rename path_from to path_to
     *
     *  Note:
     *  In order for the appropriate error message to be returned this method
     *  should not be defined if the wrapper does not support renaming files.
     */
//  public function rename($path_from, $path_to) {
//      print __METHOD__ . "\n";
//      return true;
//  }

    /**
     *  This method is called in response to rmdir().
     *  Note:
     *  In order for the appropriate error message to be returned this method
     *  should not be defined if the wrapper does not support removing files.
     */
//  public function rmdir($path, $options) {
//      print __METHOD__ . "\n";
//      return true;
//  }

    /**
     * This method is called in response to stream_select().
     */
    public function stream_cast($cast_as)
    {
        print __METHOD__ . "\n";
        return false;
    }

    /**
     *  This method is called in response to fclose().
     *  All resources that were locked, or allocated, by the wrapper should be released.
     */
    public function stream_close()
    {
        print __METHOD__ . "\n";
        // void
    }

    /**
     * This method is called in response to feof().
     *
     * Note:
     * streamWrapper::stream_eof() is called directly after calling streamWrapper::stream_read()
     * to check if EOF has been reached. If not implemented, EOF is assumed.
     */
    public function stream_eof()
    {
        print __METHOD__ . "\n";
        return $this->pointer >= $this->currentSize;
    }

    /**
     *  This method is called in response to fflush().
     *  If you have cached data in your stream but not yet stored it into
     *  the underlying storage, you should do so now.
     */
    public function stream_flush()
    {
        print __METHOD__ . "\n";
        return false;
    }

    /**
     * This method is called in response to flock(), when file_put_contents() (when flags contains LOCK_EX),
     * stream_set_blocking() and when closing the stream (LOCK_UN).
     */
    public function stream_lock($operation)
    {
        print __METHOD__ . "\n";
        switch ($operation) {
            case LOCK_SH:
            case LOCK_EX:
            case LOCK_UN:
            case LOCK_NB:
                return true;
        }
        return false;
    }

    /**
     *  This method is called to set metadata on the stream. It is called when
     *  one of the following functions is called on a stream URL:
     *      touch()
     *      chmod()
     *      chown()
     *      chgrp()
     *
     *  Note: The function is available since PHP 5.4.0
     */
//  public function stream_metadata($path, $option, $value) {
//      print __METHOD__ . "\n";
//  }

    /**
     * This method is called immediately after the wrapper is initialized (f.e. by fopen() and file_get_contents()).
     */
    public function stream_open($path, $mode, $options, &$openedPath)
    {
        print __METHOD__ . "\n";
        return true;
    }

    /**
     * This method is called in response to fread() and fgets()
     *
     * Note:
     * streamWrapper::stream_eof() is called directly after calling streamWrapper::stream_read()
     * to check if EOF has been reached. If not implemented, EOF is assumed.
     */
    public function stream_read($count)
    {
        print __METHOD__ . "\n";
        $count = min($count, $this->currentSize - $this->pointer);

        $this->pointer += $count;
        return ++self::$readChunks . '. abc';
    }

    /**
     *  This method is called in response to fseek().
     *  The read/write position of the stream should be updated according to the offset and whence.
     */
    public function stream_seek($offset, $whence = SEEK_SET)
    {
        print __METHOD__ . "\n";
        if (SEEK_SET == $whence) {
            if ($offset > $this->currentSize) return false;
            $this->pointer = $offset;
            return true;
        } else if (SEEK_CUR == $whence) {
            if ($offset + $this->pointer > $this->currentSize) return false;
            $this->pointer += $offset;
            return true;
        } else if (SEEK_END == $whence) {
            if ($offset > $this->currentSize) return false;
            $this->pointer = $this->currentSize - $offset;
            return true;
        }
    }

    /**
     * This method is called to set options on the stream.
     */
    public function stream_set_option($option, $arg1, $arg2)
    {
        print __METHOD__ . "\n";
        return false;
    }

    /**
     * This method is called in response to fstat().
     */
    public function stream_stat()
    {
        print __METHOD__ . "\n";
        return false;
    }

    /**
     * This method is called in response to fseek() to determine the current position.
     */
    public function stream_tell()
    {
        print __METHOD__ . "\n";
        return $this->pointer;
    }

    /**
     * Will respond to truncation, e.g., through ftruncate().
     */
    public function stream_truncate($new_size)
    {
        print __METHOD__ . "\n";
        return true;
    }

    /**
     * This method is called in response to fwrite().
     */
    public function stream_write($data)
    {
        print __METHOD__ . "\n";
        $dataSize = strlen($data);
        $this->pointer += $dataSize;
        $this->currentSize += $dataSize;
        return $dataSize;
    }

    /**
     * This method is called in response to unlink().
     * Note:
     * In order for the appropriate error message to be returned this method should
     * not be defined if the wrapper does not support removing files.
     */
    public function unlink($path)
    {
        print __METHOD__ . "\n";
        $url = parse_url($path);
        // deletion code here
        return true;
    }

    /*
     * This method is called in response to all stat() related functions, such as:
     *     chmod() (only when safe_mode is enabled)
     *     copy()
     *     fileperms()
     *     fileinode()
     *     filesize()
     *     fileowner()
     *     filegroup()
     *     fileatime()
     *     filemtime()
     *     filectime()
     *     filetype()
     *     is_writable()
     *     is_readable()
     *     is_executable()
     *     is_file()
     *     is_dir()
     *     is_link()
     *     file_exists()
     *     lstat()
     *     stat()
     *     ...
     */
    public function url_stat($path, $flags)
    {
        print __METHOD__ . "\n";
        return false;
    }

}